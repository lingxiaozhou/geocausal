---
title: "Step 1. Converting data to hyperframes"
output: 
  rmarkdown::html_vignette:
    toc: true
    number_sections: true
vignette: >
  %\VignetteIndexEntry{1_data_to_hfr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style type = "text/css">
h1.title {
  font-size: 30px;
}
h1 { /* Header 1 */
  font-size: 26px;
}
h2 { /* Header 2 */
    font-size: 18px;
}
h3 { /* Header 3 */
  font-size: 16px;
}
div#TOC li {
    list-style:none;
    background-image:none;
    background-repeat:none;
    background-position:0; 
}
</style>

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

options(rmarkdown.html_vignette.check_title = FALSE)

library(readr)
library(dplyr)

load("~/geocausal/Data/airstr.csv")
load("~/geocausal/Data/activ.csv")
load("~/geocausal/Data/iraq_window.Rda")

activ <- activ[, c("latitude", "longitude", "date", "type_out")]
airstr <- airstr[, c("latitude", "longitude", "date", "Type")]
```

```{r setup, include = FALSE}
devtools::load_all()
#library(geocausal)
```

The first step of spatiotemporal causal inference is to convert dataframes into an object called hyperframe. Essentially, a hyperframe is a dataframe with each cell being any types of objects, including pixel images and point processes. Users can convert dataframes into hyperframes easily with a function called <tt>get_hfr</tt>.

# Loading data

In this vignette and onwards, we use two csv files: <tt>activ.csv</tt> and <tt>airstr.csv</tt>. 

- <tt>activ.csv</tt>: locations and timings of outcomes (i.e., insurgencies) 
- <tt>airstr.csv</tt>: locations and timings of treatment (i.e., airstrikes)

Let's first check what these datasets look like.

## Outcome data

```{r}
head(activ)
```

It should be noted that location information is saved in the decimal degree format. If the original data is not in the decimal degree format, then it is recommended that you convert it to the decimal degree format.

There are three subtypes of insurgencies (column <tt>type_out</tt>): 

- improvised explosive devices (IED),
- small arms fire (SAF), and 
- other outcomes. 

```{r}
table(activ$type_out)
```

## Treatment data

```{r}
head(airstr)
```

There are two sub-categories of airstrikes: 

- airstrikes and 
- shows of force (SOF: simulated airstrikes where no weapons are released).

```{r}
table(airstr$Type)
```

# Converting the data to hyperframes

Our first task is to convert data to a collection of point processes. Intuitively, we want to generate maps of all the locations of airstrikes and insurgencies for all subtypes and all dates. For dates and subtypes with no observations, we want to generate an empty map.

[Figure here]

## <tt>get_hfr</tt> function

The key function here is <tt>get_hfr</tt>. This function does the following:

1. aggregating all observations by dates and subtypes, and converting them to a point process;
2. identifying dates with zero observations and generating an empty map for those dates; and
3. sorting everything and creating a hyperframe.

Note that a hyperframe is just like a dataframe but each element can be anything, such as point processes and pixel images.

To use <tt>get_hfr</tt>, all you need to do is to specify the following arguments:

- <tt>data</tt>: the name of the dataframe that you want to pre-process;
- <tt>subtype_column</tt>: the name of the column that specifies subtypes (of treatment or outcome);
- <tt>window</tt>: an <tt>owin</tt> element (essentially, a map of your interest);
- <tt>time_column</tt>: the name of the column for time;
- <tt>time_range</tt>: the range of time periods of your interest;
- <tt>coordinates</tt>: the names of columns for longitudes and latitudes (in this order); and
- <tt>combined</tt>: an argument for generating a combined output.

If you set <tt>combined = TRUE</tt>, then this function also returns point processes for each date, with every subtype combined. This is useful if you are interested in mapping all treatment or outcomes as one map for each date.

## Converting data to hyperframes

So let's try it out. We first convert treatment data to a hyperframe. In our dataset, coordinates are already in the decimal format, but the time variable is dates. Before using <tt>get_hfr</tt> function, we need to convert it to integers.

```{r, warning = FALSE}
# Treatment
airstr$time <- as.numeric(airstr$date - min(airstr$date) + 1) #Time variable (numeric)

treatment_hfr <- get_hfr(data = airstr,
                         subtype_column = "Type",
                         window = iraq_window,
                         time_column = "time",
                         time_range = c(1, max(airstr$time)),
                         coordinates = c("longitude", "latitude"),
                         combined = TRUE)
```


The output of this function is a hyperframe, with each element being a point process, denoted as <tt>(ppp)</tt> in the output. 

```{r, warning = FALSE}
head(treatment_hfr)
```

Since we set <tt>combined = TRUE</tt>, we have a new column <tt>all_combined</tt>, which combines <tt>Airstrike</tt> and <tt>SOF</tt> and returns an aggregated point process.

## Visualizing point processes

How does each ppp look like? One way to visualize this is to treat this hyperframe just like a dataframe and plot each observation. For example, if you are interested in airstrikes on February 24, 2007, then you can plot it as follows.

```{r, warning = FALSE, out.height=400, out.width=600, fig.dim = c(9, 6)}
plot(treatment_hfr[which(treatment_hfr$time == 1), "Airstrike"],
     main = "Airstrike (Day 1)")
```

In this plot, each circle represents the location of an airstrike, and the boundaries show the borders of Iraq (as defined by the window).

This looks fine, but you may be interested in plotting airstrikes over several days, either aggregating data over several days or visualizing them separately. In this case, <tt>vis_hfr</tt> function is useful.

To use this function, you need to specify the following:

- <tt>hfr</tt>: the name of the hyperframe;
- <tt>subtype_column</tt>: the name of the column that specifies subtypes (of treatment or outcome);
- <tt>time_column</tt>: the name of the column for time;
- <tt>time_range</tt>: the range of time periods of your interest; and
- <tt>combined</tt>: whether you want to combine all observations as one plot.

```{r, out.height=400, out.width=600, fig.dim = c(9, 6)}
vis_hfr(hfr = treatment_hfr,
        subtype_column = c("Airstrike", "SOF"),
        time_column = "time",
        range = c(1, 5),
        combined = TRUE) 
```

By setting <tt>combined = FALSE</tt>, you can also use this function to generate separate plots for each date.

```{r, out.height=400, out.width=600, fig.dim = c(9, 6)}
vis_hfr(hfr = treatment_hfr,
        subtype_column = "Airstrike",
        time_column = "time",
        range = c(1, 5),
        combined = FALSE) 
```

## Combining hyperframes

Now that we understand what hyperframes and point processes look like, we can continue to convert outcome data and combine the the two hyperframes. The output is a hyperframe with dates and point processes for both treatment and outcomes.

```{r, warning = FALSE}
# Outcome
activ$time <- as.numeric(activ$date - min(activ$date) + 1) #Time variable (numeric)

outcome_hfr <- get_hfr(data = activ,
                       subtype_column = "type_out",
                       window = iraq_window,
                       time_column = "time",
                       time_range = c(1, max(activ$time)),
                       coordinates = c("longitude", "latitude"),
                       combined = TRUE)

# Combine the two hyperframes
dat_hfr <- spatstat.geom::cbind.hyperframe(treatment_hfr, outcome_hfr[, -1])
names(dat_hfr)[names(dat_hfr) == "all_combined"] <- "all_treatment"
names(dat_hfr)[names(dat_hfr) == "all_combined.1"] <- "all_outcome"

head(dat_hfr)
```

```{r, include = FALSE}
#saveRDS(dat_hfr, file = "~/geocausal/Data/dat_hfr_1.rds")
rm(activ, airstr, treatment_hfr, outcome_hfr)
```
