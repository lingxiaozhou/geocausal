---
title: "Step 5. Obtaining observed densities"
output: 
  rmarkdown::html_vignette:
    toc: true
    number_sections: true
vignette: >
  %\VignetteIndexEntry{5_obs_density}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<style type = "text/css">
h1.title {
  font-size: 30px;
}
h1 { /* Header 1 */
  font-size: 26px;
}
h2 { /* Header 2 */
    font-size: 18px;
}
h3 { /* Header 3 */
  font-size: 16px;
}
div#TOC li {
    list-style:none;
    background-image:none;
    background-repeat:none;
    background-position:0; 
}
</style>

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
options(rmarkdown.html_vignette.check_title = FALSE)

library(readr)
library(ggplot2)
library(furrr)
library(spatstat)
library(lubridate)
```

```{r setup, include = FALSE}
devtools::load_all()
#library(geocausal)
```

```{r load data, include = FALSE}
dat_hfr <- readRDS("~/geocausal/Data/dat_hfr_4.rds")

load("~/geocausal/Data/iraq_window.Rda")
load("~/geocausal/Data/windows.RData")

## Note: all_out is previously named as attacks
```

# 1. Obtaining observed densities

Now that we have all the required data, let's move on to obtain the observed densities. The observed densities of treatment (in our example, airstrikes) will eventually be used to estimate causal effects.

The function that we use here is <tt>get_obs_density</tt>. This function has the following arguments.

- <tt>hfr</tt>: The hyperframe that we want to use
- <tt>indep_var</tt>: The variable of interest (i.e., treatment)
- <tt>dep_var</tt>: A vector of names of dependent variables
- <tt>ngrid</tt>: The number of grids (by default, 100)
- <tt>window</tt>: The window

<tt>get_obs_density</tt> function does the following tasks.

1. Fit an inhomogeneous Poisson model of <tt>treatment ~ rhs_list</tt>;
2. Obtain intensities $\lambda$ of the entire window by segmenting windows into $n = \text{ngrid}$ grid cells;
3. Integrate $\lambda$ over the entire window, which is equivalent to the estimate number of outcome events for each time period; and
4. Calculate the sum of log intensities of all observations for each time period.

The output of this function is a list of the following.

- <tt>independent_variables</tt>: A vector of the names of RHS variables
- <tt>coefficients</tt>: Coefficients of the model
- <tt>intensity_grid_cells</tt>: Intensities as images for each time period
- <tt>estimated_counts</tt>: Integrated intensities, which is the number of estimated outcome events for each time period
- <tt>sum_log_intensity</tt>: The sum of log intensities of all observations for each time period

For the estimation of causal events, we will use <tt>sum_log_intensity</tt>, but <tt>estimated_counts</tt> and <tt>intensity_grid_cells</tt> are also useful to evaluate how well our model estimates the number of outcome events.

Let's use the function <tt>get_obs_density</tt>. Since estimating the intensities over the entire window is computationally demanding, we use $\text{ngrid} = 100$.

```{r, out.height=400, out.width=600, fig.dim = c(9, 6)}
# List of RHS variables
rhs_var <- c("logPopulation", "prior_rivers", "prior_roads", "All_Cities", "aid", 
             "hist_kinetic_1", "hist_kinetic_7", "hist_kinetic_30",
             "hist_allout_1", "hist_allout_7", "hist_allout_30",
             "hist_SOF_1", "hist_SOF_7", "hist_SOF_30",
             "time.1", "time.2", "time.3",
             "Settle.IQ.G01", "Settle.IQ.G02", "Settle.IQ.G03", "Settle.IQ.G04",
             "Settle.IQ.G05", "Settle.IQ.G06", "Settle.IQ.G07", "Settle.IQ.G08",
             "Settle.IQ.G09", "Settle.IQ.G10", "Settle.IQ.G11", "Settle.IQ.G12",
             "Settle.IQ.G13", "Settle.IQ.G14", "Settle.IQ.G15", "Settle.IQ.G16",
             "Settle.IQ.G17", "Settle.IQ.G18")

# Get observed density over the entire window, for the entire period
obs_density <- get_obs_density(dat_hfr, "Airstrike", rhs_var, 
                               ngrid = 100, window = iraq_window)
##saveRDS(obs_density, file = "~/geocausal/Data/obs_density.rds")
```

Again, the output is a list of five elements that are summarized above. To see how each estimated intensities look like visually, we use plot function and select the date of interest. For example, if we are interested in the intensities of the first date of the data, then we can do the following. (We truncate the first 30 days from the original data, which is why the row ID is 31.)

```{r, out.height=400, out.width=600, fig.dim = c(9, 6)}
plot(obs_density$intensity_grid_cells[1], main = "Intensity (Grid cells)")
```

Also, we can compare the estimated and actual count measures by plotting them. 

To do so, we use a function called <tt>vis_obs_density</tt>. This function takes the following input:

- actual_data
- density_1, density_2, density_3
- color_actual
- color_dens_1, color_dens_2, color_dens_3
- time_unit

(add explanation here)

The output is a list, whose first element is the dataframe that is used to generate the plot and second element is the ggplot object.

```{r, out.height=400, out.width=600, fig.dim = c(9, 6)}
plot_compare <- vis_obs_density(actual_data = dat_hfr$Airstrike, 
                                density_1 = obs_density, density_2 = NA,
                                color_actual = "darkgray", color_dens_1 = "red",
                                time_unit = "Days")

# Second element is the plot (the first element is the dataframe)
plot_compare[[2]] +
  annotate("text", label = "Actual", x = 150, y = 50, size = 4, color = "darkgray") +
  annotate("text", label = "Predicted", x = 435, y = 20, size = 4, color = "red")
```

Just in case, let's try if the changes in the number of grid cells can affect the estimates. Even if we increase the number of grid cells from 100 to 200, the results do not differ substantially.

```{r, out.height=400, out.width=600, fig.dim = c(9, 6)}
obs_density_res <- get_obs_density(dat_hfr, "Airstrike", rhs_var, ngrid = 200, iraq_window)
##saveRDS(obs_density_res, file = "~/geocausal/Data/obs_density_res.rds")

plot_compare_double_grid <- vis_obs_density(actual_data = dat_hfr$Airstrike, 
                                            density_1 = obs_density, density_2 = obs_density_res,
                                            color_actual = "darkgray", color_dens_1 = "red", color_dens_2 = "blue",
                                            time_unit = "Days")

plot_compare_double_grid[[2]]
```

Why do results remain the same? This can be easily understood by visualizing the grid-cell-level intensities. As you can see, the intensity is almost the same as the one we obtained by setting <tt>ngrid = 100</tt>.

```{r, out.height=400, out.width=600, fig.dim = c(9, 6)}
plot(obs_density_res$intensity_grid_cells[1], main = "Intensity (Grid cells)")
```

And here's the residual plot.

```{r, out.height=400, out.width=600, fig.dim = c(9, 6)}
# Construct the residual data using the first element of plot_compare_double_plot
data_compare_residual <- plot_compare_double_grid[[1]] %>%
  dplyr::mutate(res_ng_100 = predicted_counts - actual_counts,
                res_ng_200 = predicted_counts_2 - actual_counts)

# Plot
plot_compare_residual <- ggplot(data_compare_residual) +
  geom_line(aes(x = time, y = res_ng_100), color = "red") +
  geom_line(aes(x = time, y = res_ng_200), color = "blue") +
  theme_bw() +
  annotate("text", label = "Predicted\n(ngrid = 100)", x = 400, y = 70, size = 4, color = "red") +
  annotate("text", label = "Predicted\n(ngrid = 200)", x = 430, y = 40, size = 4, color = "blue") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(title = "Residual plot comparing ngrid = 100 and 200", x = "Days", y = "Residual") + ylim(-100, 100)

plot_compare_residual
```

# Out-of-sample prediction

Then let's turn to do some out-of-sample prediction. In this vignette, we do the following experiments.

1. Dividing into test and training set and fitting the model to the training set
2. Using the entire data to fit the model, and then applying it to a subset of the data (eg, Baghdad)

To do this, we use a function called <tt>predict_obs_density</tt>. This function is basically the same as <tt>get_obs_density</tt> function, except for the fact that now we have <tt>ratio</tt> argument.

## Using a subset of data to fit the model

When you want to use a fraction of data as a training set, then you set the ratio argument of <tt>predict_obs_density</tt>. For example, if you set <tt>ratio = 0.8</tt>, then it uses the first 80% of observations as a training set and fits the model.

We use 70% and 80% of the data (first 70% and 80% observations) as training sets. Since we have a spike in the dataset, the 70% one fails to perform out-of-sample prediction.

```{r, out.height=400, out.width=600, fig.dim = c(9, 6)}
# 80% training
obs_density_8 <- predict_obs_density(dat_hfr, ratio = 0.8, "Airstrike", 
                                     rhs_var, ngrid = 100, iraq_window)
#predicted_out_8 <- out_obs_density_8$estimated_counts

# 70% training
obs_density_7 <- predict_obs_density(dat_hfr, ratio = 0.7, "Airstrike", 
                                     rhs_var, ngrid = 100, iraq_window)
#predicted_out_7 <- out_obs_density_7$estimated_counts

##out_obs_density <- list(out_obs_density_8, out_obs_density_7)
##saveRDS(out_obs_density, file = "~/geocausal/Data/out_obs_density.rds")

# Plot
plot_out_of_sample <- vis_obs_density(actual_data = dat_hfr$Airstrike, 
                                      density_1 = obs_density, density_2 = obs_density_8, density_3 = obs_density_7,
                                      color_actual = "darkgray", 
                                      color_dens_1 = "red", color_dens_2 = "blue",  color_dens_3 = "green4",
                                      time_unit = "Days")

plot_out_of_sample[[2]] +
  annotate("text", label = "Actual", x = 150, y = 50, size = 4, color = "darkgray") +
  annotate("text", label = "Predicted", x = 435, y = 15, size = 4, color = "red") +
  geom_vline(xintercept = nrow(dat_hfr), linetype = "dashed", color = "red") +
  annotate("text", label = "Out-of-sample\n(80%)", x = 390, y = 50, size = 4, color = "blue") +
  geom_vline(xintercept = obs_density_8$training_row_max, linetype = "dashed", color = "blue") +
  annotate("text", label = "Out-of-sample\n(70%)", x = 415, y = 80, size = 4, color = "green4") +
  geom_vline(xintercept = obs_density_7$training_row_max, linetype = "dashed", color = "green4")
```

The residual plot can be found below.

```{r, out.height=400, out.width=600, fig.dim = c(9, 6)}
# Construct the residual data using the first element of plot_compare_double_plot
data_out_of_sample_residual <- plot_out_of_sample[[1]] %>%
  dplyr::mutate(res_pred = predicted_counts - actual_counts,
                res_out_8 = predicted_out_8 - actual_counts,
                res_out_7 = predicted_out_7 - actual_counts)

plot_out_of_sample_residual <- ggplot(data_out_of_sample_residual) +
  geom_line(aes(x = time, y = res_pred), color = "red") +
  geom_line(aes(x = time, y = res_out_8), color = "blue") +
  geom_line(aes(x = time, y = res_out_7), color = "green4") +
  theme_bw() +
  annotate("text", label = "Predicted", x = 430, y = -25, size = 4, color = "red") +
  geom_vline(xintercept = nrow(dat_hfr), linetype = "dashed", color = "red") +
  annotate("text", label = "Out-of-sample\n(80%)", x = 430, y = -50, size = 4, color = "blue") +
  geom_vline(xintercept = obs_density_8$training_row_max, linetype = "dashed", color = "blue") +
  annotate("text", label = "Out-of-sample\n(70%)", x = 420, y = 80, size = 4, color = "green4") +
  geom_vline(xintercept = obs_density_7$training_row_max, linetype = "dashed", color = "green4") +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(title = "Residual plot comparing 80% and 70% allocations", x = "Days", y = "Residual") + ylim(-100, 100)

plot_out_of_sample_residual
```

The out-of-sample prediction is not going well, particularly when we use the first 70% of the data to fit the model. We will revisit this issue later.

## Using the entire data to fit the model, and then integrate over a subset of the data

We can use the fitted model to predict the number of airstrikes in a sub-region. In this case, we continue to use <tt>predict_obs_density</tt> function, but this time set <tt>ratio = 1</tt> and set <tt>window = windows\$Baghdad</tt>. That is, we use the entire dataset to fit the model, and then predict the counts in a window, this time Baghdad and outside of Baghdad. The window objects of Baghdad and outside of Baghdad are saved as <tt>windows\$Baghdad</tt> and <tt>windows\$outside_Baghdad</tt>, respectively.

Let's take a look at Baghdad first. Notice that for the actual count of airstrikes in Baghdad, we need to change the window from the entire Iraq to Baghdad.

```{r, out.height=400, out.width=600, fig.dim = c(9, 6)}
# Baghdad
obs_density_baghdad <- predict_obs_density(dat_hfr, ratio = 1, "Airstrike", 
                                           rhs_var, ngrid = 100, window = windows$Baghdad)

# Change the window of interest for the actual data
airstrikes_baghdad <- dat_hfr$Airstrike

for(i in 1:nrow(dat_hfr)){
  spatstat.geom::Window(airstrikes_baghdad[[i]]) <- windows$Baghdad
}

# Plot (Baghdad)
plot_compare_bag <- vis_obs_density(actual_data = airstrikes_baghdad, 
                                    density_1 = obs_density_baghdad,
                                    color_actual = "darkgray", color_dens_1 = "red",
                                    time_unit = "Days")

plot_compare_bag[[2]] +
  annotate("text", label = "Actual", x = 150, y = 50, size = 4, color = "darkgray") +
  annotate("text", label = "Predicted", x = 400, y = 70, size = 4, color = "red") +
  labs(title = "Actual vs. predicted counts of airstrikes (Baghdad)", x = "Days", y = "Count") + ylim(0, 100)
```

Then let's do the same for outside of Baghdad.

```{r, out.height=400, out.width=600, fig.dim = c(9, 6)}
# Outside of Baghdad
obs_density_out_bag <- predict_obs_density(dat_hfr, ratio = 1, "Airstrike", 
                                           rhs_var, ngrid = 100, window = windows$outside_Baghdad)

airstrikes_out_bag <- dat_hfr$Airstrike

for(i in 1:nrow(dat_hfr)){
  spatstat.geom::Window(airstrikes_out_bag[[i]]) <- windows$outside_Baghdad
}

plot_compare_out_bag <- vis_obs_density(actual_data = airstrikes_out_bag, 
                                        density_1 = obs_density_out_bag,
                                        color_actual = "darkgray", color_dens_1 = "blue",
                                        time_unit = "Days")

plot_compare_out_bag[[2]] +
  annotate("text", label = "Actual", x = 150, y = 50, size = 4, color = "darkgray") +
  annotate("text", label = "Predicted", x = 400, y = 40, size = 4, color = "blue") +
  labs(title = "Actual vs. predicted counts of airstrikes (Outside of Baghdad)", x = "Days", y = "Count") + ylim(0, 100)
```

# Considering the model appropriateness

The predicted results follow the actual trend. Yet the surge around days 300-350 seems to drive our results. This is somehow expected because we know that the new troops arrived in Baghdad on February 14, 2007 and left on July 13, 2008. Much of the actual combat was over by January 1, 2008. Hence, it would make sense to include an indicator variable for the surge. Let's try it.

```{r, out.height=400, out.width=600, fig.dim = c(9, 6)}
# Add indicator variables
min(dat_hfr$time) #The min is March 25, 2007
max(dat_hfr$time) #The max is July 5, 2008, hence the dataset is within the range of the surge

dat_hfr$surge <- ifelse(dat_hfr$time <= "2008-01-01", 1, 0)
rhs_var_surge <-  c(rhs_var, "surge")

# Get observed density over the entire window, for the entire period
obs_density_surge <- get_obs_density(dat_hfr, "Airstrike", rhs_var_surge, 
                                     ngrid = 100, window = iraq_window)

# Plot
plot_compare_surge <- vis_obs_density(actual_data = dat_hfr$Airstrike, 
                                      density_1 = obs_density, density_2 = obs_density_surge,
                                      color_actual = "darkgray", 
                                      color_dens_1 = "red", color_dens_2 = "blue",
                                      time_unit = "Days")

plot_compare_surge[[2]] +
  annotate("text", label = "Actual", x = 150, y = 50, size = 4, color = "darkgray") +
  annotate("text", label = "Predicted\n(original)", x = 410, y = 30, size = 4, color = "red") +
  annotate("text", label = "Predicted\n(surge)", x = 250, y = 70, size = 4, color = "blue") + ylim(0, 100)
```

Let's check out-of-sample prediction performance.

```{r, out.height=400, out.width=600, fig.dim = c(9, 6)}
# 80% training with surge
obs_density_8_surge <- predict_obs_density(dat_hfr, ratio = 0.8, "Airstrike", 
                                           rhs_var_surge, ngrid = 100, iraq_window)

# 70% training with surge
obs_density_7_surge <- predict_obs_density(dat_hfr, ratio = 0.7, "Airstrike", 
                                           rhs_var_surge, ngrid = 100, iraq_window)

# Plot
plot_out_of_sample_8s <- vis_obs_density(actual_data = dat_hfr$Airstrike, 
                                         density_1 = obs_density, 
                                         density_2 = obs_density_8, 
                                         density_3 = obs_density_8_surge,
                                         color_actual = "darkgray", 
                                         color_dens_1 = "red", color_dens_2 = "blue",  color_dens_3 = "green4",
                                         time_unit = "Days")

plot_out_of_sample_8s[[2]] +
  annotate("text", label = "Actual", x = 150, y = 50, size = 4, color = "darkgray") +
  annotate("text", label = "Predicted", x = 435, y = 15, size = 4, color = "red") +
  geom_vline(xintercept = nrow(dat_hfr), linetype = "dashed", color = "red") +
  annotate("text", label = "Out-of-sample\n(80%)", x = 390, y = 50, size = 4, color = "blue") +
  geom_vline(xintercept = obs_density_8$training_row_max, linetype = "dashed", color = "blue") +
  annotate("text", label = "Out-of-sample\n(80%, surge)", x = 415, y = 30, size = 4, color = "green4") +
  geom_vline(xintercept = obs_density_7$training_row_max, linetype = "dashed", color = "green4")

plot_out_of_sample_7s <- vis_obs_density(actual_data = dat_hfr$Airstrike, 
                                         density_1 = obs_density, 
                                         density_2 = obs_density_7, 
                                         density_3 = obs_density_7_surge,
                                         color_actual = "darkgray", 
                                         color_dens_1 = "red", color_dens_2 = "blue",  color_dens_3 = "green4",
                                         time_unit = "Days")

plot_out_of_sample_7s[[2]] +
  annotate("text", label = "Actual", x = 150, y = 50, size = 4, color = "darkgray") +
  annotate("text", label = "Predicted", x = 435, y = 15, size = 4, color = "red") +
  geom_vline(xintercept = nrow(dat_hfr), linetype = "dashed", color = "red") +
  annotate("text", label = "Out-of-sample\n(70%)", x = 390, y = 50, size = 4, color = "blue") +
  geom_vline(xintercept = obs_density_8$training_row_max, linetype = "dashed", color = "blue") +
  annotate("text", label = "Out-of-sample\n(70%, surge)", x = 230, y = 80, size = 4, color = "green4") +
  geom_vline(xintercept = obs_density_7$training_row_max, linetype = "dashed", color = "green4")
```

Given this result, let's then continue to use the model with the indicator.
